"use client";

import { ethers } from "ethers";
import {
  RefObject,
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";

import { FhevmInstance } from "@/fhevm/fhevmTypes";
import { FhevmDecryptionSignature } from "@/fhevm/FhevmDecryptionSignature";
import { GenericStringStorage } from "@/fhevm/GenericStringStorage";

/*
  The following two files are automatically generated by the script located at
  <root>/scripts/genabi.mjs. This script parses the
  <root>/packages/fhevm-hardhat-template/deployments directory to retrieve
  deployment information for FHEHealthChecker.sol:

  - <root>/packages/site/abi/abi/FHEHealthCheckerABI.ts
  - <root>/packages/site/abi/abi/FHEHealthCheckerAddresses.ts
*/
import { FHEHealthCheckerAddresses } from "@/abi/FHEHealthCheckerAddresses";
import { FHEHealthCheckerABI } from "@/abi/FHEHealthCheckerABI";

export type HealthStatus = "unknown" | "normal" | "low" | "high";

type FHEHealthCheckerInfoType = {
  abi: typeof FHEHealthCheckerABI.abi;
  address?: `0x${string}`;
  chainId?: number;
  chainName?: string;
};

/**
 * Resolves FHEHealthChecker contract metadata for the given EVM `chainId`.
 *
 * The ABI and address book are **generated** from the `fhevm-hardhat-template`
 * artifacts into the `@/abi` folder at build time. This function performs a
 * simple lookup in that generated map.
 *
 * Behavior:
 * - If `chainId` is `undefined` or not found in the map, returns ABI only.
 * - Otherwise returns `{ abi, address, chainId, chainName }`.
 *
 * @param chainId - Target chain id (e.g., 1, 5, 11155111). `undefined` returns ABI-only.
 * @returns Contract info for the chain or ABI-only fallback.
 * @example
 * const { abi, address } = getFHEHealthCheckerByChainId(chainId);
 */
function getFHEHealthCheckerByChainId(
  chainId: number | undefined
): FHEHealthCheckerInfoType {
  if (!chainId) {
    return { abi: FHEHealthCheckerABI.abi };
  }

  const entry =
    FHEHealthCheckerAddresses[chainId.toString() as keyof typeof FHEHealthCheckerAddresses];

  if (!entry || !("address" in entry) || entry.address === ethers.ZeroAddress) {
    return { abi: FHEHealthCheckerABI.abi, chainId };
  }

  return {
    address: entry?.address as `0x${string}` | undefined,
    chainId: entry?.chainId ?? chainId,
    chainName: entry?.chainName,
    abi: FHEHealthCheckerABI.abi,
  };
}

/**
 * Main FHEHealthChecker React component
 * - Check blood pressure using FHE operations
 * - Decrypt health status results
 */
export const useFHEHealthChecker = (parameters: {
  instance: FhevmInstance | undefined;
  fhevmDecryptionSignatureStorage: GenericStringStorage;
  eip1193Provider: ethers.Eip1193Provider | undefined;
  chainId: number | undefined;
  ethersSigner: ethers.JsonRpcSigner | undefined;
  ethersReadonlyProvider: ethers.ContractRunner | undefined;
  sameChain: RefObject<(chainId: number | undefined) => boolean>;
  sameSigner: RefObject<
    (ethersSigner: ethers.JsonRpcSigner | undefined) => boolean
  >;
}) => {
  const {
    instance,
    fhevmDecryptionSignatureStorage,
    chainId,
    ethersSigner,
    ethersReadonlyProvider,
    sameChain,
    sameSigner,
  } = parameters;

  //////////////////////////////////////////////////////////////////////////////
  // States + Refs (refs are mostly used to access latest React values and avoid
  // state dependencies). Consider @tanstack/react-query as an alternative to
  // handle async operations like FHEVM encryption/decryption
  //////////////////////////////////////////////////////////////////////////////

  const [healthStatus, setHealthStatus] = useState<HealthStatus>("unknown");
  const [encryptedStatus, setEncryptedStatus] = useState<string | undefined>(undefined);
  const [bloodPressureRanges, setBloodPressureRanges] = useState<{min: number, max: number} | undefined>(undefined);
  const [isChecking, setIsChecking] = useState<boolean>(false);
  const [isDecrypting, setIsDecrypting] = useState<boolean>(false);
  const [message, setMessage] = useState<string>("");
  const [hasChecked, setHasChecked] = useState<boolean>(false);

  const fheHealthCheckerRef = useRef<FHEHealthCheckerInfoType | undefined>(undefined);
  const isCheckingRef = useRef<boolean>(isChecking);
  const isDecryptingRef = useRef<boolean>(isDecrypting);

  //////////////////////////////////////////////////////////////////////////////
  // FHEHealthChecker
  //////////////////////////////////////////////////////////////////////////////

  const fheHealthChecker = useMemo(() => {
    const c = getFHEHealthCheckerByChainId(chainId);

    fheHealthCheckerRef.current = c;

    if (!c.address && chainId !== undefined) {
      setMessage(`FHEHealthChecker deployment not found for chainId=${chainId}.`);
    }

    return c;
  }, [chainId]);

  //////////////////////////////////////////////////////////////////////////////
  // Contract
  //////////////////////////////////////////////////////////////////////////////

  const isDeployed = useMemo(() => {
    if (!fheHealthChecker) {
      return undefined;
    }
    return (Boolean(fheHealthChecker.address) && fheHealthChecker.address !== ethers.ZeroAddress);
  }, [fheHealthChecker]);

  const canCheckBP = useMemo(() => {
    return fheHealthChecker.address && instance && ethersSigner && !isChecking;
  }, [fheHealthChecker.address, instance, ethersSigner, isChecking]);

  const canDecryptStatus = useMemo(() => {
    return (
      fheHealthChecker.address &&
      instance &&
      ethersSigner &&
      !isDecrypting &&
      hasChecked &&
      healthStatus === "unknown"
    );
  }, [
    fheHealthChecker.address,
    instance,
    ethersSigner,
    isDecrypting,
    hasChecked,
    healthStatus,
  ]);

  // Load blood pressure ranges on mount
  useEffect(() => {
    if (!fheHealthChecker.address || !ethersReadonlyProvider) {
      return;
    }

    const contract = new ethers.Contract(
      fheHealthChecker.address,
      fheHealthChecker.abi,
      ethersReadonlyProvider
    );

    contract.getBloodPressureRanges()
      .then((ranges: [bigint, bigint]) => {
        setBloodPressureRanges({
          min: Number(ranges[0]),
          max: Number(ranges[1])
        });
      })
      .catch((e) => {
        console.error("Failed to load blood pressure ranges:", e);
      });
  }, [fheHealthChecker.address, ethersReadonlyProvider, fheHealthChecker.abi]);

  /**
   * Check blood pressure using FHEVM encryption
   */
  const checkBloodPressure = useCallback(
    (bloodPressureValue: number) => {
      if (isCheckingRef.current) {
        return;
      }

      if (!fheHealthChecker.address || !instance || !ethersSigner) {
        return;
      }

      if (bloodPressureValue <= 0 || bloodPressureValue > 300) {
        setMessage("Blood pressure value must be between 1 and 300 mmHg");
        return;
      }

      const thisChainId = chainId;
      const thisFheHealthCheckerAddress = fheHealthChecker.address;
      const thisEthersSigner = ethersSigner;
      const thisFheHealthCheckerContract = new ethers.Contract(
        thisFheHealthCheckerAddress,
        fheHealthChecker.abi,
        thisEthersSigner
      );

      isCheckingRef.current = true;
      setIsChecking(true);
      setMessage(`Checking blood pressure: ${bloodPressureValue} mmHg...`);

      const run = async () => {
        // let the browser repaint before running 'input.encrypt()' (CPU-costly)
        await new Promise((resolve) => setTimeout(resolve, 100));

        const isStale = () =>
          thisFheHealthCheckerAddress !== fheHealthCheckerRef.current?.address ||
          !sameChain.current(thisChainId) ||
          !sameSigner.current(thisEthersSigner);

        try {
          // Create encrypted input
          const input = instance.createEncryptedInput(
            thisFheHealthCheckerAddress,
            thisEthersSigner.address
          );
          input.add32(bloodPressureValue);

          // Encrypt (CPU-intensive)
          const enc = await input.encrypt();

          if (isStale()) {
            setMessage("Check cancelled");
            return;
          }

          setMessage(`Calling checkBloodPressure...`);

          // Call contract
          const tx: ethers.TransactionResponse =
            await thisFheHealthCheckerContract.checkBloodPressure(
              enc.handles[0],
              enc.inputProof
            );

          setMessage(`Wait for tx:${tx.hash}...`);

          const receipt = await tx.wait();

          setMessage(`Check completed status=${receipt?.status}`);

          if (isStale()) {
            setMessage("Check cancelled");
            return;
          }

          // Get the encrypted health status from the contract
          const fheHealthCheckerContract = new ethers.Contract(
            thisFheHealthCheckerAddress,
            fheHealthChecker.abi,
            ethersReadonlyProvider
          );

          const encryptedResult = await fheHealthCheckerContract.getHealthStatus();
          setEncryptedStatus(encryptedResult);
          setHasChecked(true);

          setMessage("Health check completed! Click 'Decrypt Result' to see the status.");

        } catch (error) {
          setMessage(`Check failed: ${error}`);
        } finally {
          isCheckingRef.current = false;
          setIsChecking(false);
        }
      };

      run();
    },
    [
      ethersSigner,
      fheHealthChecker.address,
      fheHealthChecker.abi,
      instance,
      chainId,
      sameChain,
      sameSigner,
    ]
  );

  /**
   * Decrypt health status result
   */
  const decryptHealthStatus = useCallback(() => {
    if (isDecryptingRef.current) {
      return;
    }

    if (!fheHealthChecker.address || !instance || !ethersSigner) {
      return;
    }

    if (!encryptedStatus) {
      setMessage("No encrypted status to decrypt");
      return;
    }

    if (healthStatus !== "unknown") {
      return;
    }

    const thisChainId = chainId;
    const thisFheHealthCheckerAddress = fheHealthChecker.address;
    const thisEthersSigner = ethersSigner;

    isDecryptingRef.current = true;
    setIsDecrypting(true);
    setMessage("Decrypting health status...");

    const run = async () => {
      const isStale = () =>
        thisFheHealthCheckerAddress !== fheHealthCheckerRef.current?.address ||
        !sameChain.current(thisChainId) ||
        !sameSigner.current(thisEthersSigner);

      try {
        const sig: FhevmDecryptionSignature | null =
          await FhevmDecryptionSignature.loadOrSign(
            instance,
            [fheHealthChecker.address as `0x${string}`],
            ethersSigner,
            fhevmDecryptionSignatureStorage
          );

        if (!sig) {
          setMessage("Unable to build FHEVM decryption signature");
          return;
        }

        if (isStale()) {
          setMessage("Decryption cancelled");
          return;
        }

        setMessage("Calling FHEVM userDecrypt...");

        // Decrypt the result
        const res = await instance.userDecrypt(
          [{ handle: encryptedStatus, contractAddress: thisFheHealthCheckerAddress }],
          sig.privateKey,
          sig.publicKey,
          sig.signature,
          sig.contractAddresses,
          sig.userAddress,
          sig.startTimestamp,
          sig.durationDays
        );

        setMessage("Decryption completed!");

        if (isStale()) {
          setMessage("Decryption cancelled");
          return;
        }

        const statusValue = res[encryptedStatus];
        const numericValue = Number(statusValue);
        const statusText = numericValue === 0 ? "normal" : numericValue === 1 ? "low" : "high";

        setHealthStatus(statusText as HealthStatus);
        setMessage(`Health status: ${statusText.toUpperCase()}`);

      } catch (error) {
        setMessage(`Decryption failed: ${error}`);
      } finally {
        isDecryptingRef.current = false;
        setIsDecrypting(false);
      }
    };

    run();
  }, [
    fhevmDecryptionSignatureStorage,
    ethersSigner,
    fheHealthChecker.address,
    instance,
    encryptedStatus,
    healthStatus,
    chainId,
    sameChain,
    sameSigner,
  ]);

  const checkHealthMetric = useCallback(
    async (metricId: number, value: number) => {
      if (!instance || !fheHealthChecker.address || !ethersSigner || !ethersReadonlyProvider) {
        setMessage("FHEVM instance or contract not ready");
        return;
      }

      const thisChainId = chainId;
      const thisFheHealthCheckerAddress = fheHealthChecker.address;
      const thisEthersSigner = ethersSigner;
      const thisFheHealthCheckerContract = new ethers.Contract(
        thisFheHealthCheckerAddress,
        fheHealthChecker.abi,
        thisEthersSigner
      );

      // Validate input ranges based on metric
      const ranges = {
        0: { min: 50, max: 250, name: "Blood Pressure" }, // mmHg
        1: { min: 40, max: 200, name: "Heart Rate" }, // bpm
        2: { min: 40, max: 400, name: "Blood Glucose" }, // mg/dL
        3: { min: 320, max: 420, name: "Body Temperature" }, // x10 (32.0-42.0Â°C)
        4: { min: 80, max: 100, name: "Blood Oxygen" } // %
      };

      const range = ranges[metricId as keyof typeof ranges];
      if (!range) {
        setMessage("Unknown metric");
        return;
      }

      if (value < range.min || value > range.max) {
        setMessage(`${range.name} value must be between ${range.min} and ${range.max}`);
        return;
      }

      isCheckingRef.current = true;
      setIsChecking(true);
      setMessage(`Checking ${range.name}: ${value}...`);

      const run = async () => {
        await new Promise((resolve) => setTimeout(resolve, 100));

        const isStale = () =>
          thisFheHealthCheckerAddress !== fheHealthCheckerRef.current?.address ||
          !sameChain.current(thisChainId) ||
          !sameSigner.current(thisEthersSigner);

        try {
          // Create encrypted input
          const input = instance.createEncryptedInput(
            thisFheHealthCheckerAddress,
            thisEthersSigner.address
          );
          input.add32(value);

          // Encrypt (CPU-intensive)
          const enc = await input.encrypt();

          if (isStale()) {
            setMessage("Check cancelled");
            return;
          }

          setMessage(`Calling check function...`);

          // Call appropriate contract function
          let tx: ethers.TransactionResponse;
          switch (metricId) {
            case 0:
              tx = await thisFheHealthCheckerContract.checkBloodPressure(enc.handles[0], enc.inputProof);
              break;
            case 1:
              tx = await thisFheHealthCheckerContract.checkHeartRate(enc.handles[0], enc.inputProof);
              break;
            case 2:
              tx = await thisFheHealthCheckerContract.checkBloodGlucose(enc.handles[0], enc.inputProof);
              break;
            case 3:
              tx = await thisFheHealthCheckerContract.checkBodyTemperature(enc.handles[0], enc.inputProof);
              break;
            case 4:
              tx = await thisFheHealthCheckerContract.checkBloodOxygen(enc.handles[0], enc.inputProof);
              break;
            default:
              throw new Error("Unknown metric");
          }

          setMessage(`Wait for tx:${tx.hash}...`);

          const receipt = await tx.wait();

          setMessage(`Check completed status=${receipt?.status}`);

          if (isStale()) {
            setMessage("Check cancelled");
            return;
          }

          // Get the encrypted health status from the contract
          const readonlyContract = new ethers.Contract(
            thisFheHealthCheckerAddress,
            fheHealthChecker.abi,
            ethersReadonlyProvider
          );

          const encryptedResult = await readonlyContract.getHealthStatus(metricId);
          setEncryptedStatus(encryptedResult);
          setHasChecked(true);

          setMessage("Health check completed! Click 'Decrypt Result' to see the status.");

        } catch (error) {
          setMessage(`Check failed: ${error}`);
        } finally {
          isCheckingRef.current = false;
          setIsChecking(false);
        }
      };

      run();
    },
    [
      ethersSigner,
      fheHealthChecker.address,
      fheHealthChecker.abi,
      instance,
      chainId,
      sameChain,
      sameSigner,
      ethersReadonlyProvider
    ]
  );

  return {
    contractAddress: fheHealthChecker.address,
    canCheckBP,
    canDecryptStatus,
    checkBloodPressure,
    checkHealthMetric,
    decryptHealthStatus,
    isChecking,
    isDecrypting,
    message,
    healthStatus,
    bloodPressureRanges,
    isDeployed,
    hasChecked
  };
};
